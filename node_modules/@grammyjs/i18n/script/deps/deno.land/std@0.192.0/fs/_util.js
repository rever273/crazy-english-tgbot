"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSamePath = isSamePath;
exports.isSubdir = isSubdir;
exports.getFileInfoType = getFileInfoType;
exports.createWalkEntrySync = createWalkEntrySync;
exports.createWalkEntry = createWalkEntry;
exports.toPathString = toPathString;
// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.
const dntShim = __importStar(require("../../../../_dnt.shims.js"));
const path = __importStar(require("../path/mod.js"));
const mod_js_1 = require("../path/mod.js");
/**
 * Test whether `src` and `dest` resolve to the same location
 * @param src src file path
 * @param dest dest file path
 */
function isSamePath(src, dest) {
    src = toPathString(src);
    dest = toPathString(dest);
    return path.resolve(src) === path.resolve(dest);
}
/**
 * Test whether or not `dest` is a sub-directory of `src`
 * @param src src file path
 * @param dest dest file path
 * @param sep path separator
 */
function isSubdir(src, dest, sep = path.SEP) {
    if (src === dest) {
        return false;
    }
    src = toPathString(src);
    const srcArray = src.split(sep);
    dest = toPathString(dest);
    const destArray = dest.split(sep);
    return srcArray.every((current, i) => destArray[i] === current);
}
/**
 * Get a human readable file type string.
 *
 * @param fileInfo A FileInfo describes a file and is returned by `stat`,
 *                 `lstat`
 */
function getFileInfoType(fileInfo) {
    return fileInfo.isFile
        ? "file"
        : fileInfo.isDirectory
            ? "dir"
            : fileInfo.isSymlink
                ? "symlink"
                : undefined;
}
/** Create WalkEntry for the `path` synchronously */
function createWalkEntrySync(path) {
    path = toPathString(path);
    path = (0, mod_js_1.normalize)(path);
    const name = (0, mod_js_1.basename)(path);
    const info = dntShim.Deno.statSync(path);
    return {
        path,
        name,
        isFile: info.isFile,
        isDirectory: info.isDirectory,
        isSymlink: info.isSymlink,
    };
}
/** Create WalkEntry for the `path` asynchronously */
async function createWalkEntry(path) {
    path = toPathString(path);
    path = (0, mod_js_1.normalize)(path);
    const name = (0, mod_js_1.basename)(path);
    const info = await dntShim.Deno.stat(path);
    return {
        path,
        name,
        isFile: info.isFile,
        isDirectory: info.isDirectory,
        isSymlink: info.isSymlink,
    };
}
/**
 * Convert a URL or string to a path
 * @param pathUrl A URL or string to be converted
 */
function toPathString(pathUrl) {
    return pathUrl instanceof URL ? path.fromFileUrl(pathUrl) : pathUrl;
}
